<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小明的后宫花园</title>
  <subtitle>毵毵的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mingsheng.pub/"/>
  <updated>2016-09-17T04:17:57.000Z</updated>
  <id>http://mingsheng.pub/</id>
  
  <author>
    <name>张家铭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS中Sqlite的简单使用</title>
    <link href="http://mingsheng.pub/2016/09/17/iOS%E4%B8%ADSqlite%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://mingsheng.pub/2016/09/17/iOS中Sqlite的简单使用/</id>
    <published>2016-09-17T03:01:05.000Z</published>
    <updated>2016-09-17T04:17:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;<sq>!–more–&gt;</sq></p>
<h1 id="1-使用Sqlite3必备条件"><a href="#1-使用Sqlite3必备条件" class="headerlink" title="1.使用Sqlite3必备条件"></a>1.使用Sqlite3必备条件</h1><ol>
<li>Xcode7以前添加 <strong>libsqlite3.dylib</strong> 库，Xcode7以后为 <strong>libsqlite3.tbd</strong></li>
<li>添加头文件 <strong>&lt;<sq>sqlite3.h&gt;</sq></strong></li>
</ol>
<h1 id="2-一些简单常用方法的介绍"><a href="#2-一些简单常用方法的介绍" class="headerlink" title="2.一些简单常用方法的介绍"></a>2.一些简单常用方法的介绍</h1><ol>
<li>**<figure class="highlight plain"><figcaption><span>*db```**：数据库句柄，代表整个数据库实例，与文件句柄类似。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">2. **```sqlite3_open()```**： 打开数据库，没有数据库时就会创建。</div><div class="line">3. **```sqlite3_close()```**：关闭数据库文件。</div><div class="line">4. **```sqlite3_exec()```**： 执行 **非查询** 的SQL语句。</div><div class="line">5. **```sqlite3_prepare_v2```**：检测SQL语句的合法性</div><div class="line">6. **```sqlite3_step()```**：在调用sqlite3_prepare后，使用这个函数在记录集中移动。</div><div class="line">7. **```sqlite3_stmt *stmt```**：这个相当于ODBC的Command对象，用于保存编译好的SQL语句。</div><div class="line">8. **```sqlite3_bind_text```**：设置占位符，防止**SQL注入**漏洞。</div><div class="line"></div><div class="line"># 3.使用介绍</div><div class="line">1.创表:</div></pre></td></tr></table></figure></li>
</ol>
<p>// 获取应用沙盒中的数据库文件路径<br>    NSString *fileName = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@”student.sqlite”];</p>
<pre><code>// 打开数据库(没有就创建)
int result = sqlite3_open(fileName.UTF8String, &amp;_db); // _db为sqlite3 *类型的成员变量或全局变量
if (result == SQLITE_OK) {
    NSLog(@&quot;打开数据库成功&quot;);

    // 创表
    const char *sql = &quot;create table if not exists t_student (id integer primary key autoincrement, name text, age integer, password integer);&quot;;
    char *errmsg = NULL;
    int result = sqlite3_exec(_db, sql, NULL, NULL, &amp;errmsg);
    if (result == SQLITE_OK) {
        NSLog(@&quot;成功创建了student表&quot;);
    } else {
        NSLog(@&quot;创建student表失败:%s&quot;,errmsg);
    }
} else {
    NSLog(@&quot;打开数据库失败&quot;);
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2.插入数据</div></pre></td></tr></table></figure>
<pre><code>for (int i = 0; i &lt; 100; i++) {
    NSString *name = [NSString stringWithFormat:@&quot;jack%d&quot;, arc4random()%100];
    int age = arc4random()%99;
    int password = arc4random()%100;
    NSString *sql = [NSString stringWithFormat:@&quot;insert into t_student (name, age, password) values(&apos;%@&apos;, %d, %d);&quot;, name, age, password];
    char *errmsg = NULL;
    int result = sqlite3_exec(_db, sql.UTF8String, NULL, NULL, &amp;errmsg);
    if (result == SQLITE_OK) {
        NSLog(@&quot;成功添加数据&quot;);
    } else {
        NSLog(@&quot;添加数据失败&quot;);
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3.查询数据</div></pre></td></tr></table></figure>
<p>if (self.nameTextField.text.length &gt; 0) {<br>        // 标识查询结果<br>        BOOL queryResult = NO;</p>
<pre><code>    // 定义SQL语句
    NSString *sql = [NSString stringWithFormat:@&quot;select * from t_student where name = ? and password = ?;&quot;];

    // 定义一个stmt存放结果集
    sqlite3_stmt *stmt = NULL;

    // sqlite3_prepare_v2 检测SQL语句的合法性
    int result = sqlite3_prepare_v2(_db, sql.UTF8String, -1, &amp;stmt, NULL);
    if (result == SQLITE_OK) { // 查询语句合法
        NSLog(@&quot;查询语句合法&quot;); //

        // 设置占位符
    sqlite3_bind_text(stmt, 1, self.nameTextField.text.UTF8String, -1, NULL);
    sqlite3_bind_int(stmt, 2, [self.passwordTextField.text intValue]);

        // 执行SQL语句
        while (sqlite3_step(stmt) == SQLITE_ROW) { // 真的查询到一行数据
            queryResult = YES;

            // 获得第0列的数据
            int sid = sqlite3_column_int(stmt, 0);

            // 获得第1列的数据
            const unsigned char *sname = sqlite3_column_text(stmt, 1);

            // 获得第2列的数据
            int sage = sqlite3_column_int(stmt, 2);

            // 获得第3列的数据
            int spsd = sqlite3_column_int(stmt, 3);

            NSLog(@&quot;查询结果为：%d %s %d %d&quot;, sid, sname, sage, spsd);
        }

        if (queryResult == NO) {
            NSLog(@&quot;未查询到您需要的结果&quot;);
            return;
        }
    } else {
        NSLog(@&quot;查询语句不合法&quot;);
    }
} else {
    NSLog(@&quot;请输入要查询的名字&quot;);
}
</code></pre><p>```</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;lt;&lt;sq&gt;!–more–&amp;gt;&lt;/sq&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-使用Sqlite3必备条件&quot;&gt;&lt;a href=&quot;#1-使用Sqlite3必备条件&quot; class=&quot;headerlink&quot; title=&quot;1.使用Sqlite3必备条件&quot;&gt;&lt;/a&gt;1.使用Sqlit
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>竞技世界无线研发中心客户端C++笔试题</title>
    <link href="http://mingsheng.pub/2016/09/07/%E7%AB%9E%E6%8A%80%E4%B8%96%E7%95%8C%E6%97%A0%E7%BA%BF%E7%A0%94%E5%8F%91%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AFC++%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>http://mingsheng.pub/2016/09/07/竞技世界无线研发中心客户端C++笔试题/</id>
    <published>2016-09-07T13:16:48.000Z</published>
    <updated>2016-09-17T03:21:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;<sq>!–more–&gt;</sq></p>
<h1 id="一、请列举标准C-C-的基本变量类型（例如：int），以及它们的字节长度。"><a href="#一、请列举标准C-C-的基本变量类型（例如：int），以及它们的字节长度。" class="headerlink" title="一、请列举标准C/C++的基本变量类型（例如：int），以及它们的字节长度。"></a>一、请列举标准C/C++的基本变量类型（例如：int），以及它们的字节长度。</h1><h1 id="二、将二进制数110101011000转换成八进制和十六进制数。"><a href="#二、将二进制数110101011000转换成八进制和十六进制数。" class="headerlink" title="二、将二进制数110101011000转换成八进制和十六进制数。"></a>二、将二进制数110101011000转换成八进制和十六进制数。</h1><h1 id="三、请写出下面几个表达式的结果，答案可以用10进制或16进制书写。"><a href="#三、请写出下面几个表达式的结果，答案可以用10进制或16进制书写。" class="headerlink" title="三、请写出下面几个表达式的结果，答案可以用10进制或16进制书写。"></a>三、请写出下面几个表达式的结果，答案可以用10进制或16进制书写。</h1><ul>
<li>oxaa | 0x55</li>
<li>15 &amp; 240</li>
<li>10 ^ 12</li>
<li>(int)((signed char)(-2) &gt;&gt; 1)</li>
<li>(int)((unsigned char)(254) &gt;&gt; 1)</li>
</ul>
<h1 id="四、new-delete-与-malloc-free-的联系与区别？请用new写出一个不抛出异常的内存分配语句。"><a href="#四、new-delete-与-malloc-free-的联系与区别？请用new写出一个不抛出异常的内存分配语句。" class="headerlink" title="四、new delete 与 malloc free 的联系与区别？请用new写出一个不抛出异常的内存分配语句。"></a>四、new delete 与 malloc free 的联系与区别？请用new写出一个不抛出异常的内存分配语句。</h1><h1 id="五、-include和-include”xxx-h”有什么区别"><a href="#五、-include和-include”xxx-h”有什么区别" class="headerlink" title="五、#include和#include”xxx.h”有什么区别?"></a>五、#include<xxx.h>和#include”xxx.h”有什么区别?</xxx.h></h1><h1 id="六、请计算-sizeof-的值"><a href="#六、请计算-sizeof-的值" class="headerlink" title="六、请计算 sizeof 的值:"></a>六、请计算 sizeof 的值:</h1><table>
<thead>
<tr>
<th style="text-align:center">char str[] = “Hello”;</th>
<th style="text-align:center">sizeof(str) =</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">char *p = str;</td>
<td style="text-align:center">sizeof(p) =</td>
</tr>
<tr>
<td style="text-align:center">int n = 10;</td>
<td style="text-align:center">sizeof(n) =</td>
</tr>
<tr>
<td style="text-align:center">char str[100];</td>
<td style="text-align:center">sizeof(str) =</td>
</tr>
<tr>
<td style="text-align:center">void *p = malloc(100);</td>
<td style="text-align:center">sizeof(p) =</td>
</tr>
<tr>
<td style="text-align:center">class Empty {};</td>
<td style="text-align:center">sizeof(Empty) =</td>
</tr>
<tr>
<td style="text-align:center">typedef struct {char c1; char c2; long n;} stru;</td>
<td style="text-align:center">sizeof(stru) =</td>
</tr>
</tbody>
</table>
<h1 id="七、extern-“C”-的作用是什么？"><a href="#七、extern-“C”-的作用是什么？" class="headerlink" title="七、extern “C” 的作用是什么？"></a>七、extern “C” 的作用是什么？</h1><h1 id="八、定义一个接受-string-类型返回类型为-bool-的函数指针。"><a href="#八、定义一个接受-string-类型返回类型为-bool-的函数指针。" class="headerlink" title="八、定义一个接受 string 类型返回类型为 bool 的函数指针。"></a>八、定义一个接受 string 类型返回类型为 bool 的函数指针。</h1><h1 id="九、请说出-const-与-define-相比，有何有点？"><a href="#九、请说出-const-与-define-相比，有何有点？" class="headerlink" title="九、请说出 const 与#define 相比，有何有点？"></a>九、请说出 const 与#define 相比，有何有点？</h1><h1 id="十、请说出下面的指针类型"><a href="#十、请说出下面的指针类型" class="headerlink" title="十、请说出下面的指针类型:"></a>十、请说出下面的指针类型:</h1><ul>
<li>int *p[n];</li>
<li>int (*)p[n];</li>
<li>int *p();</li>
<li>int (*)p();</li>
</ul>
<h1 id="十一、指出下面代码的问题"><a href="#十一、指出下面代码的问题" class="headerlink" title="十一、指出下面代码的问题:"></a>十一、指出下面代码的问题:</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class TimeKeeper &#123;</div><div class="line">	public:</div><div class="line">	TimeKeeper() &#123;...&#125;;</div><div class="line">	~TimeKeeper() &#123;...&#125;;</div><div class="line">	...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class AtomicClock : public TimeKeeper &#123;...&#125;;</div><div class="line">TimeKeeper* p = new AtomicClock();</div><div class="line">...</div><div class="line">delete p;</div></pre></td></tr></table></figure>
<h1 id="十二、简述进程和线程的区别"><a href="#十二、简述进程和线程的区别" class="headerlink" title="十二、简述进程和线程的区别?"></a>十二、简述进程和线程的区别?</h1><h1 id="十三、内存题：请问以下四种情况，运行-Test-函数会有怎样的结果？"><a href="#十三、内存题：请问以下四种情况，运行-Test-函数会有怎样的结果？" class="headerlink" title="十三、内存题：请问以下四种情况，运行 Test 函数会有怎样的结果？"></a>十三、内存题：请问以下四种情况，运行 Test 函数会有怎样的结果？</h1><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void GetMemory(char *p)</div><div class="line">&#123;</div><div class="line">	p = (char *)malloc(100);</div><div class="line">&#125;</div><div class="line">void Test(void)</div><div class="line">&#123;</div><div class="line">	char *str = NULL;</div><div class="line">	GetMemory(str);</div><div class="line">	strcpy(str, &quot;hello world&quot;);</div><div class="line">	printf(str);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">char *GetMemory(void)</div><div class="line">&#123;</div><div class="line">	char p[] = &quot;hello world&quot;;</div><div class="line">	return p;</div><div class="line">&#125;</div><div class="line">void Test(void)</div><div class="line">&#123;</div><div class="line">	char *str = NULL;</div><div class="line">	str = GetMemory();</div><div class="line">	printf(str);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void GetMemory(char **p, int num)</div><div class="line">&#123;</div><div class="line">	*p = (char *)malloc(num);</div><div class="line">&#125;</div><div class="line">void Test(void) </div><div class="line">&#123;</div><div class="line">	char *str = NULL;</div><div class="line">	GetMemory(&amp;str, 100);</div><div class="line">	strcpy(str, &quot;hello&quot;);</div><div class="line">	printf(str);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void Test(void)</div><div class="line">&#123;</div><div class="line">	char *str = (char *)malloc(100);</div><div class="line">	strcpy(str, &quot;hello&quot;);</div><div class="line">	free(str);</div><div class="line">	if (str != NULL)</div><div class="line">	&#123;</div><div class="line">		strcpy(str, &quot;world&quot;);</div><div class="line">		printf(str);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="十四、请写出下面代码的输出结果"><a href="#十四、请写出下面代码的输出结果" class="headerlink" title="十四、请写出下面代码的输出结果:"></a>十四、请写出下面代码的输出结果:</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class MyClass</div><div class="line">&#123;</div><div class="line">	public:</div><div class="line">		MyClass()</div><div class="line">		&#123;</div><div class="line">			printf(&quot;Construct MyClass\n&quot;);</div><div class="line">		&#125;;</div><div class="line">		void SayHello(void)</div><div class="line">		&#123;</div><div class="line">			printf(&quot;Hello\n&quot;);</div><div class="line">		&#125;	</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void TestMyClass(void)</div><div class="line">&#123;</div><div class="line">	printf(&quot;Test Myclass\n&quot;);</div><div class="line">	static MyClass MyClassForTesting;</div><div class="line">	MyClassForTesting.SayHello();</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	TestMyClass();</div><div class="line">	TestMyClass();</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="十五、请写出下面代码的输出结果"><a href="#十五、请写出下面代码的输出结果" class="headerlink" title="十五、请写出下面代码的输出结果:"></a>十五、请写出下面代码的输出结果:</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream.h&gt;</div><div class="line">class BaseCounter</div><div class="line">&#123;</div><div class="line">	protected:</div><div class="line">		long int count;</div><div class="line">	</div><div class="line">	public:</div><div class="line">		void Countlt(int x, int y = 10, int z = 20)</div><div class="line">		&#123;</div><div class="line">			count = 0;</div><div class="line">			cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;endl;</div><div class="line">		&#125;</div><div class="line">		BaseCounter()</div><div class="line">		&#123;</div><div class="line">			count = 0;</div><div class="line">		&#125;	</div><div class="line">		BaseCounter(int x)</div><div class="line">		&#123;</div><div class="line">			count = x;</div><div class="line">		&#125;</div><div class="line">&#125;;</div><div class="line">class DerivedCounter: public BaseCounter</div><div class="line">&#123;</div><div class="line">	public:</div><div class="line">	DerivedCounter()</div><div class="line">	&#123;&#125;</div><div class="line">	DerivedCounter(int x): BaseCounter(x)</div><div class="line">	&#123;&#125;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	DerivedCounter objDC(30);</div><div class="line">	objDC.Countlt(40, 50);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="十六、C-语言实现函数-void-memmove-void-dest-const-void-src-size-t-n-。函数的功能是拷贝src所指的内存内容前-n-个字节到-dest-所指的地址上。"><a href="#十六、C-语言实现函数-void-memmove-void-dest-const-void-src-size-t-n-。函数的功能是拷贝src所指的内存内容前-n-个字节到-dest-所指的地址上。" class="headerlink" title="十六、C 语言实现函数 void memmove(void dest, const void *src, size_t n)。函数的功能是拷贝src所指的内存内容前 n 个字节到 dest 所指的地址上。"></a>十六、C 语言实现函数 void<em> memmove(void </em>dest, const void *src, size_t n)。函数的功能是拷贝src所指的内存内容前 n 个字节到 dest 所指的地址上。</h1><h1 id="十七、完成下面操作单链表的函数："><a href="#十七、完成下面操作单链表的函数：" class="headerlink" title="十七、完成下面操作单链表的函数："></a>十七、完成下面操作单链表的函数：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 从单链表中删除指定item</div><div class="line">typdef struct SingleListNode</div><div class="line">&#123;</div><div class="line">	int value;</div><div class="line">	Struct SingleLisrNode* next;</div><div class="line">&#125;SingleListNode;</div><div class="line"></div><div class="line">void deleteNode(SingleListNode* pitem)</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="十八、实现一个快排算法。"><a href="#十八、实现一个快排算法。" class="headerlink" title="十八、实现一个快排算法。"></a>十八、实现一个快排算法。</h1><h1 id="十九、写一个函数找出一个整数数组中第二大的值。"><a href="#十九、写一个函数找出一个整数数组中第二大的值。" class="headerlink" title="十九、写一个函数找出一个整数数组中第二大的值。"></a>十九、写一个函数找出一个整数数组中第二大的值。</h1><h1 id="二十、实现一个洗牌算法，int-cards-52-该数组存放着0到51，使其完全打乱，不可以使用随机函数。"><a href="#二十、实现一个洗牌算法，int-cards-52-该数组存放着0到51，使其完全打乱，不可以使用随机函数。" class="headerlink" title="二十、实现一个洗牌算法，int cards[52],该数组存放着0到51，使其完全打乱，不可以使用随机函数。"></a>二十、实现一个洗牌算法，int cards[52],该数组存放着0到51，使其完全打乱，不可以使用随机函数。</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;lt;&lt;sq&gt;!–more–&amp;gt;&lt;/sq&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、请列举标准C-C-的基本变量类型（例如：int），以及它们的字节长度。&quot;&gt;&lt;a href=&quot;#一、请列举标准C-C-的基本变量类型（例如：int），以及它们的字节长度。&quot; class=&quot;heade
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa进阶</title>
    <link href="http://mingsheng.pub/2016/08/01/ReactiveCocoa%E8%BF%9B%E9%98%B6/"/>
    <id>http://mingsheng.pub/2016/08/01/ReactiveCocoa进阶/</id>
    <published>2016-08-01T12:29:43.000Z</published>
    <updated>2016-09-13T13:51:56.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h3 id="1-ReactiveCocoa常见操作方法介绍。"><a href="#1-ReactiveCocoa常见操作方法介绍。" class="headerlink" title="1.ReactiveCocoa常见操作方法介绍。"></a>1.ReactiveCocoa常见操作方法介绍。</h3><ul>
<li><p>1.1 ReactiveCocoa操作须知</p>
<ul>
<li>所有的信号（RACSignal）都可以进行操作处理，因为所有操作方法都定义在RACStream.h中，而RACSignal继承RACStream。</li>
</ul>
</li>
<li><p>1.2 ReactiveCocoa操作思想</p>
<ul>
<li>运用的是Hook（钩子）思想，Hook是一种用于改变API(应用程序编程接口：方法)执行结果的技术.</li>
<li>Hook用处：截获API调用的技术。</li>
<li>Hook原理：在每次调用一个API返回结果之前，先执行你自己的方法，改变结果的输出。</li>
<li>RAC开发方式：RAC中核心开发方式，也是<code>绑定</code>，之前的开发方式是<code>赋值</code>，而用RAC开发，应该把重心放在绑定，也就是可以在创建一个对象的时候，就绑定好以后想要做的事情，而不是等赋值之后在去做事情。</li>
<li>列如：把数据展示到控件上，之前都是重写控件的setModel方法，用RAC就可以在一开始创建控件的时候，就绑定好数据。</li>
</ul>
</li>
<li><p>1.3 ReactiveCocoa核心方法bind</p>
<ul>
<li><p>ReactiveCocoa操作的核心方法是<code>bind</code>（绑定）,给RAC中的信号进行绑定，只要信号一发送数据，就能监听到，从而把发送数据改成自己想要的数据。</p>
</li>
<li><p>在开发中很少使用bind方法，bind属于RAC中的底层方法，RAC已经封装了很多好用的其他方法，底层都是调用bind，用法比bind简单.</p>
</li>
<li><code>bind</code>方法简单介绍和使用。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">// 假设想监听文本框的内容，并且在每次输出结果的时候，都在文本框的内容拼接一段文字“输出：”</div><div class="line"></div><div class="line">// 方式一:在返回结果后，拼接。</div><div class="line">    [_textField.rac_textSignal subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">        NSLog(@&quot;输出:%@&quot;,x);</div><div class="line"></div><div class="line">    &#125;];</div><div class="line"></div><div class="line">// 方式二:在返回结果前，拼接，使用RAC中bind方法做处理。</div><div class="line">// bind方法参数:需要传入一个返回值是RACStreamBindBlock的block参数</div><div class="line">// RACStreamBindBlock是一个block的类型，返回值是信号，参数（value,stop），因此参数的block返回值也是一个block。</div><div class="line"></div><div class="line">// RACStreamBindBlock:</div><div class="line">// 参数一(value):表示接收到信号的原始值，还没做处理</div><div class="line">// 参数二(*stop):用来控制绑定Block，如果*stop = yes,那么就会结束绑定。</div><div class="line">// 返回值：信号，做好处理，在通过这个信号返回出去，一般使用RACReturnSignal,需要手动导入头文件RACReturnSignal.h。</div><div class="line"></div><div class="line">// bind方法使用步骤:</div><div class="line">// 1.传入一个返回值RACStreamBindBlock的block。</div><div class="line">// 2.描述一个RACStreamBindBlock类型的bindBlock作为block的返回值。</div><div class="line">// 3.描述一个返回结果的信号，作为bindBlock的返回值。</div><div class="line">// 注意：在bindBlock中做信号结果的处理。</div><div class="line"></div><div class="line">// 底层实现:</div><div class="line">// 1.源信号调用bind,会重新创建一个绑定信号。</div><div class="line">// 2.当绑定信号被订阅，就会调用绑定信号中的didSubscribe，生成一个bindingBlock。</div><div class="line">// 3.当源信号有内容发出，就会把内容传递到bindingBlock处理，调用bindingBlock(value,stop)</div><div class="line">// 4.调用bindingBlock(value,stop)，会返回一个内容处理完成的信号（RACReturnSignal）。</div><div class="line">// 5.订阅RACReturnSignal，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。</div><div class="line"></div><div class="line">// 注意:不同订阅者，保存不同的nextBlock，看源码的时候，一定要看清楚订阅者是哪个。</div><div class="line">// 这里需要手动导入#import &lt;ReactiveCocoa/RACReturnSignal.h&gt;，才能使用RACReturnSignal。</div><div class="line"></div><div class="line">[[_textField.rac_textSignal bind:^RACStreamBindBlock&#123;</div><div class="line"></div><div class="line">    // 什么时候调用:</div><div class="line">    // block作用:表示绑定了一个信号.</div><div class="line"></div><div class="line">    return ^RACStream *(id value, BOOL *stop)&#123;</div><div class="line"></div><div class="line">        // 什么时候调用block:当信号有新的值发出，就会来到这个block。</div><div class="line"></div><div class="line">        // block作用:做返回值的处理</div><div class="line"></div><div class="line">        // 做好处理，通过信号返回出去.</div><div class="line">        return [RACReturnSignal return:[NSString stringWithFormat:@&quot;输出:%@&quot;,value]];</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;%@&quot;,x);</div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<ul>
<li><p>1.4ReactiveCocoa操作方法之映射(flattenMap,Map)</p>
<ul>
<li><code>flattenMap</code>，<code>Map</code>用于把源信号内容映射成新的内容。</li>
</ul>
</li>
</ul>
<p><code>flattenMap</code>简单使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"> // 监听文本框的内容改变，把结构重新映射成一个新值.</div><div class="line"></div><div class="line">// flattenMap作用:把源信号的内容映射成一个新的信号，信号可以是任意类型。</div><div class="line"></div><div class="line">  // flattenMap使用步骤:</div><div class="line">  // 1.传入一个block，block类型是返回值RACStream，参数value</div><div class="line">  // 2.参数value就是源信号的内容，拿到源信号的内容做处理</div><div class="line">  // 3.包装成RACReturnSignal信号，返回出去。</div><div class="line"></div><div class="line">  // flattenMap底层实现:</div><div class="line">  // 0.flattenMap内部调用bind方法实现的,flattenMap中block的返回值，会作为bind中bindBlock的返回值。</div><div class="line">  // 1.当订阅绑定信号，就会生成bindBlock。</div><div class="line">  // 2.当源信号发送内容，就会调用bindBlock(value, *stop)</div><div class="line">  // 3.调用bindBlock，内部就会调用flattenMap的block，flattenMap的block作用：就是把处理好的数据包装成信号。</div><div class="line">  // 4.返回的信号最终会作为bindBlock中的返回信号，当做bindBlock的返回信号。</div><div class="line">  // 5.订阅bindBlock的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  [[_textField.rac_textSignal flattenMap:^RACStream *(id value) &#123;</div><div class="line"></div><div class="line">      // block什么时候 : 源信号发出的时候，就会调用这个block。</div><div class="line"></div><div class="line">      // block作用 : 改变源信号的内容。</div><div class="line"></div><div class="line">      // 返回值：绑定信号的内容.</div><div class="line">      return [RACReturnSignal return:[NSString stringWithFormat:@&quot;输出:%@&quot;,value]];</div><div class="line"></div><div class="line">  &#125;] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">      // 订阅绑定信号，每当源信号发送内容，做完处理，就会调用这个block。</div><div class="line"></div><div class="line">      NSLog(@&quot;%@&quot;,x);</div><div class="line"></div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<p> <code>Map</code>简单使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 监听文本框的内容改变，把结构重新映射成一个新值.</div><div class="line"></div><div class="line">   // Map作用:把源信号的值映射成一个新的值</div><div class="line"></div><div class="line">   // Map使用步骤:</div><div class="line">   // 1.传入一个block,类型是返回对象，参数是value</div><div class="line">   // 2.value就是源信号的内容，直接拿到源信号的内容做处理</div><div class="line">   // 3.把处理好的内容，直接返回就好了，不用包装成信号，返回的值，就是映射的值。</div><div class="line"></div><div class="line">   // Map底层实现:</div><div class="line">   // 0.Map底层其实是调用flatternMap,Map中block中的返回的值会作为flatternMap中block中的值。</div><div class="line">   // 1.当订阅绑定信号，就会生成bindBlock。</div><div class="line">   // 3.当源信号发送内容，就会调用bindBlock(value, *stop)</div><div class="line">   // 4.调用bindBlock，内部就会调用flattenMap的block</div><div class="line">   // 5.flattenMap的block内部会调用Map中的block，把Map中的block返回的内容包装成返回的信号。</div><div class="line">   // 5.返回的信号最终会作为bindBlock中的返回信号，当做bindBlock的返回信号。</div><div class="line">   // 6.订阅bindBlock的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。</div><div class="line"></div><div class="line">      [[_textField.rac_textSignal map:^id(id value) &#123;</div><div class="line">       // 当源信号发出，就会调用这个block，修改源信号的内容</div><div class="line">       // 返回值：就是处理完源信号的内容。</div><div class="line">       return [NSString stringWithFormat:@&quot;输出:%@&quot;,value];</div><div class="line">   &#125;] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">       NSLog(@&quot;%@&quot;,x);</div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
<ul>
<li><p><code>FlatternMap和Map的区别</code></p>
<ul>
<li>1.FlatternMap中的Block返回信号。</li>
<li>2.Map中的Block返回对象。</li>
<li>3.开发中，如果信号发出的值不是信号，映射一般使用Map</li>
<li>4.开发中，如果信号发出的值是信号，映射一般使用FlatternMap。</li>
</ul>
</li>
<li><p><code>总结</code>：signalOfsignals用FlatternMap。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 创建信号中的信号</div><div class="line">RACSubject *signalOfsignals = [RACSubject subject];</div><div class="line">RACSubject *signal = [RACSubject subject];</div><div class="line"></div><div class="line">[[signalOfsignals flattenMap:^RACStream *(id value) &#123;</div><div class="line"></div><div class="line"> // 当signalOfsignals的signals发出信号才会调用</div><div class="line"></div><div class="line">    return value;</div><div class="line"></div><div class="line">&#125;] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    // 只有signalOfsignals的signal发出信号才会调用，因为内部订阅了bindBlock中返回的信号，也就是flattenMap返回的信号。</div><div class="line">    // 也就是flattenMap返回的信号发出内容，才会调用。</div><div class="line"></div><div class="line">    NSLog(@&quot;%@aaa&quot;,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">// 信号的信号发送信号</div><div class="line">[signalOfsignals sendNext:signal];</div><div class="line"></div><div class="line">// 信号发送内容</div><div class="line">[signal sendNext:@1];</div></pre></td></tr></table></figure>
<ul>
<li>1.5 ReactiveCocoa操作方法之组合。<ul>
<li><code>concat</code>:按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">    [subscriber sendNext:@1];</div><div class="line"></div><div class="line">    [subscriber sendCompleted];</div><div class="line"></div><div class="line">    return nil;</div><div class="line">&#125;];</div><div class="line">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">    [subscriber sendNext:@2];</div><div class="line"></div><div class="line">    return nil;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">// 把signalA拼接到signalB后，signalA发送完成，signalB才会被激活。</div><div class="line">RACSignal *concatSignal = [signalA concat:signalB];</div><div class="line"></div><div class="line">// 以后只需要面对拼接信号开发。</div><div class="line">// 订阅拼接的信号，不需要单独订阅signalA，signalB</div><div class="line">// 内部会自动订阅。</div><div class="line">// 注意：第一个信号必须发送完成，第二个信号才会被激活</div><div class="line">[concatSignal subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;%@&quot;,x);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line">// concat底层实现:</div><div class="line">// 1.当拼接信号被订阅，就会调用拼接信号的didSubscribe</div><div class="line">// 2.didSubscribe中，会先订阅第一个源信号（signalA）</div><div class="line">// 3.会执行第一个源信号（signalA）的didSubscribe</div><div class="line">// 4.第一个源信号（signalA）didSubscribe中发送值，就会调用第一个源信号（signalA）订阅者的nextBlock,通过拼接信号的订阅者把值发送出来.</div><div class="line">// 5.第一个源信号（signalA）didSubscribe中发送完成，就会调用第一个源信号（signalA）订阅者的completedBlock,订阅第二个源信号（signalB）这时候才激活（signalB）。</div><div class="line">// 6.订阅第二个源信号（signalB）,执行第二个源信号（signalB）的didSubscribe</div><div class="line">// 7.第二个源信号（signalA）didSubscribe中发送值,就会通过拼接信号的订阅者把值发送出来.</div></pre></td></tr></table></figure>
<ul>
<li><code>then</code>:用于连接两个信号，当第一个信号完成，才会连接then返回的信号。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> // then:用于连接两个信号，当第一个信号完成，才会连接then返回的信号</div><div class="line">// 注意使用then，之前信号的值会被忽略掉.</div><div class="line">// 底层实现：1、先过滤掉之前的信号发出的值。2.使用concat连接then返回的信号</div><div class="line">[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">    [subscriber sendNext:@1];</div><div class="line">    [subscriber sendCompleted];</div><div class="line">    return nil;</div><div class="line">&#125;] then:^RACSignal *&#123;</div><div class="line">    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        [subscriber sendNext:@2];</div><div class="line">        return nil;</div><div class="line">    &#125;];</div><div class="line">&#125;] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    // 只能接收到第二个信号的值，也就是then返回信号的值</div><div class="line">    NSLog(@&quot;%@&quot;,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<ul>
<li><code>merge</code>:把多个信号合并为一个信号，任何一个信号有新值的时候就会调用.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">// merge:把多个信号合并成一个信号</div><div class="line">//创建多个信号</div><div class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">    [subscriber sendNext:@1];</div><div class="line"></div><div class="line"></div><div class="line">    return nil;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">    [subscriber sendNext:@2];</div><div class="line"></div><div class="line">    return nil;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">// 合并信号,任何一个信号发送数据，都能监听到.</div><div class="line">RACSignal *mergeSignal = [signalA merge:signalB];</div><div class="line"></div><div class="line">[mergeSignal subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;%@&quot;,x);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line">// 底层实现：</div><div class="line">// 1.合并信号被订阅的时候，就会遍历所有信号，并且发出这些信号。</div><div class="line">// 2.每发出一个信号，这个信号就会被订阅</div><div class="line">// 3.也就是合并信号一被订阅，就会订阅里面所有的信号。</div><div class="line">// 4.只要有一个信号被发出就会被监听。</div></pre></td></tr></table></figure>
<ul>
<li><code>zipWith</code>:把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">    [subscriber sendNext:@1];</div><div class="line"></div><div class="line"></div><div class="line">    return nil;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">    [subscriber sendNext:@2];</div><div class="line"></div><div class="line">    return nil;</div><div class="line">&#125;];</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// 压缩信号A，信号B</div><div class="line">RACSignal *zipSignal = [signalA zipWith:signalB];</div><div class="line"></div><div class="line">[zipSignal subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;%@&quot;,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">// 底层实现:</div><div class="line">// 1.定义压缩信号，内部就会自动订阅signalA，signalB</div><div class="line">// 2.每当signalA或者signalB发出信号，就会判断signalA，signalB有没有发出个信号，有就会把最近发出的信号都包装成元组发出。</div></pre></td></tr></table></figure>
<ul>
<li><code>combineLatest</code>:将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">  RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">    [subscriber sendNext:@1];</div><div class="line"></div><div class="line">    return nil;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">    [subscriber sendNext:@2];</div><div class="line"></div><div class="line">    return nil;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">// 把两个信号组合成一个信号,跟zip一样，没什么区别</div><div class="line">RACSignal *combineSignal = [signalA combineLatestWith:signalB];</div><div class="line"></div><div class="line">[combineSignal subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;%@&quot;,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">// 底层实现：</div><div class="line">// 1.当组合信号被订阅，内部会自动订阅signalA，signalB,必须两个信号都发出内容，才会被触发。</div><div class="line">// 2.并且把两个信号组合成元组发出。</div></pre></td></tr></table></figure>
<ul>
<li><code>reduce</code>聚合:用于信号发出的内容是元组，把信号发出元组的值聚合成一个值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">  RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">     [subscriber sendNext:@1];</div><div class="line"></div><div class="line">     return nil;</div><div class="line"> &#125;];</div><div class="line"></div><div class="line"> RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">     [subscriber sendNext:@2];</div><div class="line"></div><div class="line">     return nil;</div><div class="line"> &#125;];</div><div class="line"></div><div class="line"> // 聚合</div><div class="line"> // 常见的用法，（先组合在聚合）。combineLatest:(id&lt;NSFastEnumeration&gt;)signals reduce:(id (^)())reduceBlock</div><div class="line"> // reduce中的block简介:</div><div class="line"> // reduceblcok中的参数，有多少信号组合，reduceblcok就有多少参数，每个参数就是之前信号发出的内容</div><div class="line"> // reduceblcok的返回值：聚合信号之后的内容。</div><div class="line">RACSignal *reduceSignal = [RACSignal combineLatest:@[signalA,signalB] reduce:^id(NSNumber *num1 ,NSNumber *num2)&#123;</div><div class="line"></div><div class="line">    return [NSString stringWithFormat:@&quot;%@ %@&quot;,num1,num2];</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"> [reduceSignal subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">     NSLog(@&quot;%@&quot;,x);</div><div class="line"> &#125;];</div><div class="line"></div><div class="line"> // 底层实现:</div><div class="line"> // 1.订阅聚合信号，每次有内容发出，就会执行reduceblcok，把信号内容转换成reduceblcok返回的值。</div></pre></td></tr></table></figure>
<ul>
<li><p>1.6 ReactiveCocoa操作方法之过滤。</p>
<ul>
<li><p><code>filter</code>:过滤信号，使用它可以获取满足条件的信号.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 过滤:</div><div class="line">// 每次信号发出，会先执行过滤条件判断.</div><div class="line">[_textField.rac_textSignal filter:^BOOL(NSString *value) &#123;</div><div class="line">        return value.length &gt; 3;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
<li><p><code>ignore</code>:忽略完某些值的信号.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    // 内部调用filter过滤，忽略掉ignore的值</div><div class="line">[[_textField.rac_textSignal ignore:@&quot;1&quot;] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;%@&quot;,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
<li><p><code>distinctUntilChanged</code>:当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    // 过滤，当上一次和当前的值不一样，就会发出内容。</div><div class="line">// 在开发中，刷新UI经常使用，只有两次数据不一样才需要刷新</div><div class="line">[[_textField.rac_textSignal distinctUntilChanged] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;%@&quot;,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
<li><p><code>take</code>:从开始一共取N次的信号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 1、创建信号</div><div class="line">RACSubject *signal = [RACSubject subject];</div><div class="line"></div><div class="line">// 2、处理信号，订阅信号</div><div class="line">[[signal take:1] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;%@&quot;,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">// 3.发送信号</div><div class="line">[signal sendNext:@1];</div><div class="line"></div><div class="line">[signal sendNext:@2];</div></pre></td></tr></table></figure>
</li>
<li><p><code>takeLast</code>:取最后N次的信号,前提条件，订阅者必须调用完成，因为只有完成，就知道总共有多少信号.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 1、创建信号</div><div class="line">RACSubject *signal = [RACSubject subject];</div><div class="line"></div><div class="line">// 2、处理信号，订阅信号</div><div class="line">[[signal takeLast:1] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;%@&quot;,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">// 3.发送信号</div><div class="line">[signal sendNext:@1];</div><div class="line"></div><div class="line">[signal sendNext:@2];</div><div class="line"></div><div class="line">[signal sendCompleted];</div></pre></td></tr></table></figure>
</li>
<li><p><code>takeUntil</code>:(RACSignal *):获取信号直到执行完这个信号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 监听文本框的改变，知道当前对象被销毁</div><div class="line">[_textField.rac_textSignal takeUntil:self.rac_willDeallocSignal];</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>skip</code>:(NSUInteger):跳过几个信号,不接受。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 表示输入第一次，不会被监听到，跳过第一次发出的信号</div><div class="line">[[_textField.rac_textSignal skip:1] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;%@&quot;,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<ul>
<li><p><code>switchToLatest</code>:用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">RACSubject *signalOfSignals = [RACSubject subject];</div><div class="line">RACSubject *signal = [RACSubject subject];</div><div class="line">[signalOfSignals sendNext:signal];</div><div class="line">[signal sendNext:@1];</div><div class="line"></div><div class="line">// 获取信号中信号最近发出信号，订阅最近发出的信号。</div><div class="line">// 注意switchToLatest：只能用于信号中的信号</div><div class="line">[signalOfSignals.switchToLatest subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;%@&quot;,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>1.7 ReactiveCocoa操作方法之秩序。</p>
<ul>
<li><code>doNext</code>: 执行Next之前，会先执行这个Block</li>
<li><p><code>doCompleted</code>: 执行sendCompleted之前，会先执行这个Block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">       [subscriber sendNext:@1];</div><div class="line">       [subscriber sendCompleted];</div><div class="line">       return nil;</div><div class="line">   &#125;] doNext:^(id x) &#123;</div><div class="line">     // 执行[subscriber sendNext:@1];之前会调用这个Block</div><div class="line">       NSLog(@&quot;doNext&quot;);;</div><div class="line">   &#125;] doCompleted:^&#123;</div><div class="line">        // 执行[subscriber sendCompleted];之前会调用这个Block</div><div class="line">       NSLog(@&quot;doCompleted&quot;);;</div><div class="line"></div><div class="line">   &#125;] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">       NSLog(@&quot;%@&quot;,x);</div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
</li>
<li><p>1.8 ReactiveCocoa操作方法之线程。</p>
</li>
<li><p><code>deliverOn</code>: 内容传递切换到制定线程中，副作用在原来线程中,把在创建信号时block中的代码称之为副作用。</p>
</li>
<li><p><code>subscribeOn</code>: 内容传递和副作用都会切换到制定线程中。</p>
</li>
</ul>
</li>
<li><p>1.9 ReactiveCocoa操作方法之时间。</p>
<ul>
<li><p><code>timeout</code>：超时，可以让一个信号在一定的时间后，自动报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">    return nil;</div><div class="line">&#125;] timeout:1 onScheduler:[RACScheduler currentScheduler]];</div><div class="line"></div><div class="line">[signal subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;%@&quot;,x);</div><div class="line">&#125; error:^(NSError *error) &#123;</div><div class="line">    // 1秒后会自动调用</div><div class="line">    NSLog(@&quot;%@&quot;,error);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
<li><p><code>interval</code> 定时：每隔一段时间发出信号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[RACSignal interval:1 onScheduler:[RACScheduler currentScheduler]] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">       NSLog(@&quot;%@&quot;,x);</div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
</li>
<li><p><code>delay</code> 延迟发送next。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    RACSignal *signal = [[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">    [subscriber sendNext:@1];</div><div class="line">    return nil;</div><div class="line">&#125;] delay:2] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;%@&quot;,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>1.9 ReactiveCocoa操作方法之重复。</p>
<ul>
<li><code>retry</code>重试 ：只要失败，就会重新执行创建信号中的block,直到成功.</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> __block int i = 0;</div><div class="line">[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">        if (i == 10) &#123;</div><div class="line">            [subscriber sendNext:@1];</div><div class="line">        &#125;else&#123;</div><div class="line">            NSLog(@&quot;接收到错误&quot;);</div><div class="line">            [subscriber sendError:nil];</div><div class="line">        &#125;</div><div class="line">        i++;</div><div class="line"></div><div class="line">    return nil;</div><div class="line"></div><div class="line">&#125;] retry] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;%@&quot;,x);</div><div class="line"></div><div class="line">&#125; error:^(NSError *error) &#123;</div><div class="line"></div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<ul>
<li><code>replay</code>重放：当一个信号被多次订阅,反复播放内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line"></div><div class="line">    [subscriber sendNext:@1];</div><div class="line">    [subscriber sendNext:@2];</div><div class="line"></div><div class="line">    return nil;</div><div class="line">&#125;] replay];</div><div class="line"></div><div class="line">[signal subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;第一个订阅者%@&quot;,x);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line">[signal subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;第二个订阅者%@&quot;,x);</div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<ul>
<li><code>throttle</code>节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">    RACSubject *signal = [RACSubject subject];</div><div class="line"></div><div class="line">_signal = signal;</div><div class="line"></div><div class="line">// 节流，在一定时间（1秒）内，不接收任何信号内容，过了这个时间（1秒）获取最后发送的信号内容发出。</div><div class="line">[[signal throttle:1] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;%@&quot;,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="2-介绍MVVM架构思想。"><a href="#2-介绍MVVM架构思想。" class="headerlink" title="2.介绍MVVM架构思想。"></a>2.介绍MVVM架构思想。</h3><p>2.1 程序为什么要架构：<code>便于程序员开发和维护代码。</code></p>
<p>2.2 常见的架构思想:</p>
<ul>
<li><p><code>MVC</code> M:模型 V:视图 C:控制器</p>
</li>
<li><p><code>MVVM</code> M:模型 V:视图+控制器 VM:视图模型</p>
</li>
<li><p><code>MVCS</code> M:模型 V:视图 C:控制器 C:服务类</p>
</li>
<li><p><code>VIPER</code> V:视图 I:交互器 P:展示器 E:实体 R:路由 (<a href="http://www.cocoachina.com/ios/20140703/9016.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20140703/9016.html</a>)</p>
</li>
</ul>
<p>2.3 MVVM介绍</p>
<ul>
<li><p><code>模型</code>(M):保存视图数据。</p>
</li>
<li><p><code>视图+控制器</code>(V):展示内容 + 如何展示</p>
</li>
<li><p><code>视图模型</code>(VM):处理展示的业务逻辑，包括按钮的点击，数据的请求和解析等等。</p>
</li>
</ul>
<h3 id="3-ReactiveCocoa-MVVM-实战一：登录界面"><a href="#3-ReactiveCocoa-MVVM-实战一：登录界面" class="headerlink" title="3.ReactiveCocoa + MVVM 实战一：登录界面"></a>3.ReactiveCocoa + MVVM 实战一：登录界面</h3><ul>
<li>3.1需求+分析+步骤</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/* 需求：1.监听两个文本框的内容，有内容才允许按钮点击</div><div class="line">        2.默认登录请求.</div><div class="line"></div><div class="line">   用MVVM：实现，之前界面的所有业务逻辑</div><div class="line">   分析：1.之前界面的所有业务逻辑都交给控制器做处理</div><div class="line">        2.在MVVM架构中把控制器的业务全部搬去VM模型，也就是每个控制器对应一个VM模型.</div><div class="line"></div><div class="line">   步骤：1.创建LoginViewModel类，处理登录界面业务逻辑.</div><div class="line">        2.这个类里面应该保存着账号的信息，创建一个账号Account模型</div><div class="line">        3.LoginViewModel应该保存着账号信息Account模型。</div><div class="line">        4.需要时刻监听Account模型中的账号和密码的改变，怎么监听？</div><div class="line">        5.在非RAC开发中，都是习惯赋值，在RAC开发中，需要改变开发思维，由赋值转变为绑定，可以在一开始初始化的时候，就给Account模型中的属性绑定，并不需要重写set方法。</div><div class="line">        6.每次Account模型的值改变，就需要判断按钮能否点击，在VM模型中做处理，给外界提供一个能否点击按钮的信号.</div><div class="line">        7.这个登录信号需要判断Account中账号和密码是否有值，用KVO监听这两个值的改变，把他们聚合成登录信号.</div><div class="line">        8.监听按钮的点击，由VM处理，应该给VM声明一个RACCommand，专门处理登录业务逻辑.</div><div class="line">        9.执行命令，把数据包装成信号传递出去</div><div class="line">        10.监听命令中信号的数据传递</div><div class="line">        11.监听命令的执行时刻</div><div class="line"> */</div></pre></td></tr></table></figure>
<ul>
<li>3.2 控制器的代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) LoginViewModel *loginViewModel;</div><div class="line"></div><div class="line">@property (weak, nonatomic) IBOutlet UITextField *accountField;</div><div class="line">@property (weak, nonatomic) IBOutlet UITextField *pwdField;</div><div class="line"></div><div class="line">@property (weak, nonatomic) IBOutlet UIButton *loginBtn;</div><div class="line"></div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">- (LoginViewModel *)loginViewModel</div><div class="line">&#123;</div><div class="line">    if (_loginViewModel == nil) &#123;</div><div class="line"></div><div class="line">        _loginViewModel = [[LoginViewModel alloc] init];</div><div class="line">    &#125;</div><div class="line">    return _loginViewModel;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 视图模型绑定</div><div class="line">- (void)bindModel</div><div class="line">&#123;</div><div class="line">    // 给模型的属性绑定信号</div><div class="line">    // 只要账号文本框一改变，就会给account赋值</div><div class="line">    RAC(self.loginViewModel.account, account) = _accountField.rac_textSignal;</div><div class="line">    RAC(self.loginViewModel.account, pwd) = _pwdField.rac_textSignal;</div><div class="line"></div><div class="line">    // 绑定登录按钮</div><div class="line">    RAC(self.loginBtn,enabled) = self.loginViewModel.enableLoginSignal;</div><div class="line"></div><div class="line">   // 监听登录按钮点击</div><div class="line">    [[_loginBtn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">        // 执行登录事件</div><div class="line">        [self.loginViewModel.LoginCommand execute:nil];</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>3.3 VM的代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">@interface LoginViewModel : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, strong) Account *account;</div><div class="line"></div><div class="line"></div><div class="line">// 是否允许登录的信号</div><div class="line">@property (nonatomic, strong, readonly) RACSignal *enableLoginSignal;</div><div class="line"></div><div class="line">@property (nonatomic, strong, readonly) RACCommand *LoginCommand;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation LoginViewModel</div><div class="line">- (Account *)account</div><div class="line">&#123;</div><div class="line">    if (_account == nil) &#123;</div><div class="line">        _account = [[Account alloc] init];</div><div class="line">    &#125;</div><div class="line">    return _account;</div><div class="line">&#125;</div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        [self initialBind];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 初始化绑定</div><div class="line">- (void)initialBind</div><div class="line">&#123;</div><div class="line">    // 监听账号的属性值改变，把他们聚合成一个信号。</div><div class="line">    _enableLoginSignal = [RACSignal combineLatest:@[RACObserve(self.account, account),RACObserve(self.account, pwd)] reduce:^id(NSString *account,NSString *pwd)&#123;</div><div class="line"></div><div class="line">        return @(account.length &amp;&amp; pwd.length);</div><div class="line"></div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    // 处理登录业务逻辑</div><div class="line">    _LoginCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123;</div><div class="line"></div><div class="line">        NSLog(@&quot;点击了登录&quot;);</div><div class="line">        return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">            // 模仿网络延迟</div><div class="line">            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line"></div><div class="line">                [subscriber sendNext:@&quot;登录成功&quot;];</div><div class="line"></div><div class="line">                // 数据传送完毕，必须调用完成，否则命令永远处于执行状态</div><div class="line">                [subscriber sendCompleted];</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            return nil;</div><div class="line">        &#125;];</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    // 监听登录产生的数据</div><div class="line">    [_LoginCommand.executionSignals.switchToLatest subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">        if ([x isEqualToString:@&quot;登录成功&quot;]) &#123;</div><div class="line">            NSLog(@&quot;登录成功&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    // 监听登录状态</div><div class="line">    [[_LoginCommand.executing skip:1] subscribeNext:^(id x) &#123;</div><div class="line">        if ([x isEqualToNumber:@(YES)]) &#123;</div><div class="line"></div><div class="line">            // 正在登录ing...</div><div class="line">            // 用蒙版提示</div><div class="line">            [MBProgressHUD showMessage:@&quot;正在登录...&quot;];</div><div class="line"></div><div class="line"></div><div class="line">        &#125;else</div><div class="line">        &#123;</div><div class="line">            // 登录成功</div><div class="line">            // 隐藏蒙版</div><div class="line">            [MBProgressHUD hideHUD];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-ReactiveCocoa-MVVM-实战二：网络请求数据"><a href="#4-ReactiveCocoa-MVVM-实战二：网络请求数据" class="headerlink" title="4.ReactiveCocoa + MVVM 实战二：网络请求数据"></a>4.ReactiveCocoa + MVVM 实战二：网络请求数据</h3><ul>
<li><p>4.1 接口：这里先给朋友介绍一个免费的网络数据接口，<code>豆瓣</code>。可以经常用来练习一些网络请求的小Demo.</p>
</li>
<li><p>4.2 需求+分析+步骤</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">    需求：请求豆瓣图书信息，url:https://api.douban.com/v2/book/search?q=基础</div><div class="line"></div><div class="line">    分析：请求一样，交给VM模型管理</div><div class="line"></div><div class="line">    步骤:</div><div class="line">        1.控制器提供一个视图模型（requesViewModel），处理界面的业务逻辑</div><div class="line">        2.VM提供一个命令，处理请求业务逻辑</div><div class="line">        3.在创建命令的block中，会把请求包装成一个信号，等请求成功的时候，就会把数据传递出去。</div><div class="line">        4.请求数据成功，应该把字典转换成模型，保存到视图模型中，控制器想用就直接从视图模型中获取。</div><div class="line">        5.假设控制器想展示内容到tableView，直接让视图模型成为tableView的数据源，把所有的业务逻辑交给视图模型去做，这样控制器的代码就非常少了。</div><div class="line"> */</div></pre></td></tr></table></figure>
<ul>
<li>4.3控制器代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) UITableView *tableView;</div><div class="line"></div><div class="line">@property (nonatomic, strong) RequestViewModel *requesViewModel;</div><div class="line"></div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line">- (RequestViewModel *)requesViewModel</div><div class="line">&#123;</div><div class="line">    if (_requesViewModel == nil) &#123;</div><div class="line">        _requesViewModel = [[RequestViewModel alloc] init];</div><div class="line">    &#125;</div><div class="line">    return _requesViewModel;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    // Do any additional setup after loading the view, typically from a nib.</div><div class="line"></div><div class="line">    // 创建tableView</div><div class="line">    UITableView *tableView = [[UITableView alloc] initWithFrame:self.view.bounds];</div><div class="line">    tableView.dataSource = self.requesViewModel;</div><div class="line">    self.requesViewModel.tableView = tableView;</div><div class="line">    [self.view addSubview:tableView];</div><div class="line"></div><div class="line">    // 执行请求</div><div class="line">    [self.requesViewModel.reuqesCommand execute:nil];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<ul>
<li>4.4视图模型(VM)代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">@interface RequestViewModel : NSObject&lt;UITableViewDataSource&gt;</div><div class="line"></div><div class="line"></div><div class="line">	// 请求命令</div><div class="line">	@property (nonatomic, strong, readonly) RACCommand *reuqesCommand;</div><div class="line"></div><div class="line">	//模型数组</div><div class="line">	@property (nonatomic, strong, readonly) NSArray *models;</div><div class="line"></div><div class="line">	// 控制器中的view</div><div class="line">	@property (nonatomic, weak) UITableView *tableView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation RequestViewModel</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line"></div><div class="line">        [self initialBind];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)initialBind</div><div class="line">&#123;</div><div class="line">    _reuqesCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123;</div><div class="line"></div><div class="line">        RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line"></div><div class="line">            NSMutableDictionary *parameters = [NSMutableDictionary dictionary];</div><div class="line">            parameters[@&quot;q&quot;] = @&quot;基础&quot;;</div><div class="line"></div><div class="line">            // 发送请求</div><div class="line">            [[AFHTTPRequestOperationManager manager] GET:@&quot;https://api.douban.com/v2/book/search&quot; parameters:parameters success:^(AFHTTPRequestOperation * _Nonnull operation, id  _Nonnull responseObject) &#123;</div><div class="line">                NSLog(@&quot;%@&quot;,responseObject);</div><div class="line"></div><div class="line">                // 请求成功调用</div><div class="line">                // 把数据用信号传递出去</div><div class="line">                [subscriber sendNext:responseObject];</div><div class="line"></div><div class="line">                [subscriber sendCompleted];</div><div class="line"></div><div class="line"></div><div class="line">            &#125; failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) &#123;</div><div class="line">                // 请求失败调用</div><div class="line"></div><div class="line">            &#125;];</div><div class="line"></div><div class="line">            return nil;</div><div class="line">        &#125;];</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        // 在返回数据信号时，把数据中的字典映射成模型信号，传递出去</div><div class="line">        return [requestSignal map:^id(NSDictionary *value) &#123;</div><div class="line">            NSMutableArray *dictArr = value[@&quot;books&quot;];</div><div class="line"></div><div class="line">            // 字典转模型，遍历字典中的所有元素，全部映射成模型，并且生成数组</div><div class="line">            NSArray *modelArr = [[dictArr.rac_sequence map:^id(id value) &#123;</div><div class="line"></div><div class="line">                return [Book bookWithDict:value];</div><div class="line">            &#125;] array];</div><div class="line"></div><div class="line">            return modelArr;</div><div class="line">        &#125;];</div><div class="line"></div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    // 获取请求的数据</div><div class="line">    [_reuqesCommand.executionSignals.switchToLatest subscribeNext:^(NSArray *x) &#123;</div><div class="line"></div><div class="line">        // 有了新数据，刷新表格</div><div class="line">        _models = x;</div><div class="line"></div><div class="line">        // 刷新表格</div><div class="line">        [self.tableView reloadData];</div><div class="line"></div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - UITableViewDataSource</div><div class="line"></div><div class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section</div><div class="line">&#123;</div><div class="line">    return self.models.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">    static NSString *ID = @&quot;cell&quot;;</div><div class="line">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];</div><div class="line">    if (cell == nil) &#123;</div><div class="line"></div><div class="line">        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Book *book = self.models[indexPath.row];</div><div class="line">    cell.detailTextLabel.text = book.subtitle;</div><div class="line">    cell.textLabel.text = book.title;</div><div class="line"></div><div class="line">    return cell;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;1-ReactiveCocoa常见操作方法介绍。&quot;&gt;&lt;a href=&quot;#1-ReactiveCocoa常见操作方法介绍。&quot; class=&quot;headerlink&quot; title=&quot;1.ReactiveCocoa常见操作方法介绍。&quot;&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa初探</title>
    <link href="http://mingsheng.pub/2016/08/01/ReactiveCocoa%E5%88%9D%E6%8E%A2/"/>
    <id>http://mingsheng.pub/2016/08/01/ReactiveCocoa初探/</id>
    <published>2016-08-01T12:29:06.000Z</published>
    <updated>2016-09-13T13:51:45.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h3 id="1-ReactiveCocoa简介"><a href="#1-ReactiveCocoa简介" class="headerlink" title="1.ReactiveCocoa简介"></a>1.ReactiveCocoa简介</h3><p>ReactiveCocoa（简称为<code>RAC</code>）,是由Github开源的一个应用于iOS和OS开发的新框架,Cocoa是苹果整套框架的简称，因此很多苹果框架喜欢以Cocoa结尾。</p>
<h3 id="2-ReactiveCocoa作用"><a href="#2-ReactiveCocoa作用" class="headerlink" title="2.ReactiveCocoa作用"></a>2.ReactiveCocoa作用</h3><p>在我们iOS开发过程中，经常会响应某些事件来处理某些业务逻辑，例如按钮的点击，上下拉刷新，网络请求，属性的变化（通过KVO）或者用户位置的变化（通过CoreLocation）。但是这些事件都用不同的方式来处理，比如action、delegate、KVO、callback等。</p>
<p>其实这些事件，都可以通过RAC处理，ReactiveCocoa为事件提供了很多处理方法，而且利用RAC处理事件很方便，可以把要处理的事情，和监听的事情的代码放在一起，这样非常方便我们管理，就不需要跳到对应的方法里。非常符合我们开发中<code>高聚合，低耦合</code>的思想。</p>
<h3 id="3-编程思想"><a href="#3-编程思想" class="headerlink" title="3.编程思想"></a>3.编程思想</h3><p>在开发中我们也不能太依赖于某个框架，否则这个框架不更新了，导致项目后期没办法维护，比如之前Facebook提供的<code>Three20框架</code>，在当时也是神器，但是后来不更新了，也就没什么人用了。因此我感觉学习一个框架，还是有必要了解它的<code>编程思想</code>。</p>
<p>先简单介绍下目前咱们已知的<code>编程思想</code>。</p>
<p>3.1 <code>面向过程</code>：处理事情以过程为核心，一步一步的实现。</p>
<p>3.2 <code>面向对象</code>：万物皆对象</p>
<p>3.3 <code>链式编程思想</code>：是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。a(1).b(2).c(3)</p>
<ul>
<li><code>链式编程特点</code>：方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值）</li>
</ul>
<p>3.4 <code>响应式编程思想</code>：不需要考虑调用顺序，只需要知道考虑结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，借用面向对象的一句话，万物皆是流。</p>
<p>3.5 <code>函数式编程思想</code>：是把操作尽量写成一系列嵌套的函数或者方法调用。</p>
<ul>
<li><p><code>函数式编程本质</code>:就是往方法中传入Block,方法中嵌套Block调用，把代码聚合起来管理</p>
</li>
<li><p><code>函数式编程特点</code>：每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果）</p>
</li>
</ul>
<h3 id="4-ReactiveCocoa编程思想"><a href="#4-ReactiveCocoa编程思想" class="headerlink" title="4.ReactiveCocoa编程思想"></a>4.ReactiveCocoa编程思想</h3><p>ReactiveCocoa结合了几种编程风格：</p>
<p><code>函数式编程（Functional Programming）</code></p>
<p><code>响应式编程（Reactive Programming）</code></p>
<p>所以，你可能听说过ReactiveCocoa被描述为函数响应式编程（FRP）框架。</p>
<p>使用RAC解决问题，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。</p>
<h3 id="5-ReactiveCocoa常见类。"><a href="#5-ReactiveCocoa常见类。" class="headerlink" title="5.ReactiveCocoa常见类。"></a>5.ReactiveCocoa常见类。</h3><p>学习框架首要之处:个人认为先要搞清楚框架中常用的类，在RAC中最核心的类RACSiganl,搞定这个类就能用ReactiveCocoa开发了。</p>
<p><code>RACSiganl</code>:信号类,一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。</p>
<ul>
<li><p>信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。</p>
</li>
<li><p>默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。</p>
</li>
<li><p>如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。</p>
</li>
<li><p><code>RACSiganl简单使用:</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">// RACSignal使用步骤：</div><div class="line">   // 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe</div><div class="line">   // 2.订阅信号,才会激活信号. - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</div><div class="line">   // 3.发送信号 - (void)sendNext:(id)value</div><div class="line"></div><div class="line"></div><div class="line">   // RACSignal底层实现：</div><div class="line">   // 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。</div><div class="line">   // 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock</div><div class="line">   // 2.2 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。</div><div class="line">   // 2.1 subscribeNext内部会调用siganl的didSubscribe</div><div class="line">   // 3.siganl的didSubscribe中调用[subscriber sendNext:@1];</div><div class="line">   // 3.1 sendNext底层其实就是执行subscriber的nextBlock</div><div class="line"></div><div class="line">   // 1.创建信号</div><div class="line">   RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">       // block调用时刻：每当有订阅者订阅信号，就会调用block。</div><div class="line"></div><div class="line">       // 2.发送信号</div><div class="line">       [subscriber sendNext:@1];</div><div class="line"></div><div class="line">       // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。</div><div class="line">       [subscriber sendCompleted];</div><div class="line"></div><div class="line">       return [RACDisposable disposableWithBlock:^&#123;</div><div class="line"></div><div class="line">           // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。</div><div class="line"></div><div class="line">           // 执行完Block后，当前信号就不在被订阅了。</div><div class="line"></div><div class="line">           NSLog(@&quot;信号被销毁&quot;);</div><div class="line"></div><div class="line">       &#125;];</div><div class="line">   &#125;];</div><div class="line"></div><div class="line">   // 3.订阅信号,才会激活信号.</div><div class="line">   [siganl subscribeNext:^(id x) &#123;</div><div class="line">       // block调用时刻：每当有信号发出数据，就会调用block.</div><div class="line">       NSLog(@&quot;接收到数据:%@&quot;,x);</div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
<p><code>RACSubscriber</code>:表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。</p>
<p><code>RACDisposable</code>:用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。</p>
<ul>
<li><code>使用场景</code>:不想监听某个信号时，可以通过它主动取消订阅信号。</li>
</ul>
<p><code>RACSubject</code>:RACSubject:信号提供者，自己可以充当信号，又能发送信号。</p>
<ul>
<li><code>使用场景</code>:通常用来代替代理，有了它，就不必要定义代理了。</li>
</ul>
<p><code>RACReplaySubject</code>:重复提供信号类，RACSubject的子类。</p>
<ul>
<li><code>RACReplaySubject</code>与<code>RACSubject</code>区别:<ul>
<li>RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。</li>
</ul>
</li>
<li><code>使用场景一</code>:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。</li>
<li><p><code>使用场景二</code>:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。</p>
</li>
<li><p><code>RACSubject和RACReplaySubject简单使用:</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// RACSubject使用步骤</div><div class="line">// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</div><div class="line">// 2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</div><div class="line">// 3.发送信号 sendNext:(id)value</div><div class="line"></div><div class="line">// RACSubject:底层实现和RACSignal不一样。</div><div class="line">// 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。</div><div class="line">// 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</div><div class="line"></div><div class="line">// 1.创建信号</div><div class="line">RACSubject *subject = [RACSubject subject];</div><div class="line"></div><div class="line">// 2.订阅信号</div><div class="line">[subject subscribeNext:^(id x) &#123;</div><div class="line">    // block调用时刻：当信号发出新值，就会调用.</div><div class="line">    NSLog(@&quot;第一个订阅者%@&quot;,x);</div><div class="line">&#125;];</div><div class="line">[subject subscribeNext:^(id x) &#123;</div><div class="line">    // block调用时刻：当信号发出新值，就会调用.</div><div class="line">    NSLog(@&quot;第二个订阅者%@&quot;,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">// 3.发送信号</div><div class="line">[subject sendNext:@&quot;1&quot;];</div><div class="line"></div><div class="line"></div><div class="line">// RACReplaySubject使用步骤:</div><div class="line">// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</div><div class="line">// 2.可以先订阅信号，也可以先发送信号。</div><div class="line">// 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</div><div class="line">// 2.2 发送信号 sendNext:(id)value</div><div class="line"></div><div class="line">// RACReplaySubject:底层实现和RACSubject不一样。</div><div class="line">// 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</div><div class="line">// 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock</div><div class="line"></div><div class="line">// 如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。</div><div class="line">// 也就是先保存值，在订阅值。</div><div class="line"></div><div class="line">// 1.创建信号</div><div class="line">RACReplaySubject *replaySubject = [RACReplaySubject subject];</div><div class="line"></div><div class="line">// 2.发送信号</div><div class="line">[replaySubject sendNext:@1];</div><div class="line">[replaySubject sendNext:@2];</div><div class="line"></div><div class="line">// 3.订阅信号</div><div class="line">[replaySubject subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;第一个订阅者接收到的数据%@&quot;,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">// 订阅信号</div><div class="line">[replaySubject subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;第二个订阅者接收到的数据%@&quot;,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<ul>
<li><code>RACSubject替换代理</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">	// 需求:</div><div class="line">	// 1.给当前控制器添加一个按钮，modal到另一个控制器界面</div><div class="line">	// 2.另一个控制器view中有个按钮，点击按钮，通知当前控制器</div><div class="line"></div><div class="line">步骤一：在第二个控制器.h，添加一个RACSubject代替代理。</div><div class="line">@interface TwoViewController : UIViewController</div><div class="line"></div><div class="line">@property (nonatomic, strong) RACSubject *delegateSignal;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">步骤二：监听第二个控制器按钮点击</div><div class="line">@implementation TwoViewController</div><div class="line">- (IBAction)notice:(id)sender &#123;</div><div class="line">    // 通知第一个控制器，告诉它，按钮被点了</div><div class="line"></div><div class="line">     // 通知代理</div><div class="line">     // 判断代理信号是否有值</div><div class="line">    if (self.delegateSignal) &#123;</div><div class="line">        // 有值，才需要通知</div><div class="line">        [self.delegateSignal sendNext:nil];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.</div><div class="line">@implementation OneViewController</div><div class="line">- (IBAction)btnClick:(id)sender &#123;</div><div class="line"></div><div class="line">    // 创建第二个控制器</div><div class="line">    TwoViewController *twoVc = [[TwoViewController alloc] init];</div><div class="line"></div><div class="line">    // 设置代理信号</div><div class="line">    twoVc.delegateSignal = [RACSubject subject];</div><div class="line"></div><div class="line">    // 订阅代理信号</div><div class="line">    [twoVc.delegateSignal subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">        NSLog(@&quot;点击了通知按钮&quot;);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    // 跳转到第二个控制器</div><div class="line">    [self presentViewController:twoVc animated:YES completion:nil];</div><div class="line"></div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>RACTuple</code>:元组类,类似NSArray,用来包装值.</p>
<p><code>RACSequence</code>:RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。</p>
<p><code>使用场景</code>：1.字典转模型</p>
<p><code>RACSequence和RACTuple简单使用</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">    // 1.遍历数组</div><div class="line">    NSArray *numbers = @[@1,@2,@3,@4];</div><div class="line"></div><div class="line">    // 这里其实是三步</div><div class="line">    // 第一步: 把数组转换成集合RACSequence numbers.rac_sequence</div><div class="line">    // 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal</div><div class="line">    // 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。</div><div class="line">    [numbers.rac_sequence.signal subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">        NSLog(@&quot;%@&quot;,x);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line"></div><div class="line">    // 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象)</div><div class="line">    NSDictionary *dict = @&#123;@&quot;name&quot;:@&quot;xmg&quot;,@&quot;age&quot;:@18&#125;;</div><div class="line">    [dict.rac_sequence.signal subscribeNext:^(RACTuple *x) &#123;</div><div class="line"></div><div class="line">        // 解包元组，会把元组的值，按顺序给参数里面的变量赋值</div><div class="line">        RACTupleUnpack(NSString *key,NSString *value) = x;</div><div class="line"></div><div class="line">        // 相当于以下写法</div><div class="line">//        NSString *key = x[0];</div><div class="line">//        NSString *value = x[1];</div><div class="line"></div><div class="line">        NSLog(@&quot;%@ %@&quot;,key,value);</div><div class="line"></div><div class="line">    &#125;];</div><div class="line"></div><div class="line"></div><div class="line">    // 3.字典转模型</div><div class="line">    // 3.1 OC写法</div><div class="line">    NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];</div><div class="line"></div><div class="line">    NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];</div><div class="line"></div><div class="line">    NSMutableArray *items = [NSMutableArray array];</div><div class="line"></div><div class="line">    for (NSDictionary *dict in dictArr) &#123;</div><div class="line">        FlagItem *item = [FlagItem flagWithDict:dict];</div><div class="line">        [items addObject:item];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 3.2 RAC写法</div><div class="line">    NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];</div><div class="line"></div><div class="line">    NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];</div><div class="line"></div><div class="line">    NSMutableArray *flags = [NSMutableArray array];</div><div class="line"></div><div class="line">    _flags = flags;</div><div class="line"></div><div class="line">    // rac_sequence注意点：调用subscribeNext，并不会马上执行nextBlock，而是会等一会。</div><div class="line">    [dictArr.rac_sequence.signal subscribeNext:^(id x) &#123;</div><div class="line">        // 运用RAC遍历字典，x：字典</div><div class="line"></div><div class="line">        FlagItem *item = [FlagItem flagWithDict:x];</div><div class="line"></div><div class="line">        [flags addObject:item];</div><div class="line"></div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    NSLog(@&quot;%@&quot;,  NSStringFromCGRect([UIScreen mainScreen].bounds));</div><div class="line"></div><div class="line"></div><div class="line">    // 3.3 RAC高级写法:</div><div class="line">    NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];</div><div class="line"></div><div class="line">    NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];</div><div class="line">    // map:映射的意思，目的：把原始值value映射成一个新值</div><div class="line">    // array: 把集合转换成数组</div><div class="line">    // 底层实现：当信号被订阅，会遍历集合中的原始值，映射成新值，并且保存到新的数组里。</div><div class="line">    NSArray *flags = [[dictArr.rac_sequence map:^id(id value) &#123;</div><div class="line"></div><div class="line">        return [FlagItem flagWithDict:value];</div><div class="line"></div><div class="line">    &#125;] array];</div></pre></td></tr></table></figure>
<p><code>RACMulticastConnection</code>:用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。</p>
<p><code>使用注意</code>:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建.</p>
<p><code>RACMulticastConnection简单使用</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"> // RACMulticastConnection使用步骤:</div><div class="line"> // 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe</div><div class="line"> // 2.创建连接 RACMulticastConnection *connect = [signal publish];</div><div class="line"> // 3.订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock]</div><div class="line"> // 4.连接 [connect connect]</div><div class="line"></div><div class="line"> // RACMulticastConnection底层原理:</div><div class="line"> // 1.创建connect，connect.sourceSignal -&gt; RACSignal(原始信号)  connect.signal -&gt; RACSubject</div><div class="line"> // 2.订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。</div><div class="line"> // 3.[connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject</div><div class="line"> // 3.1.订阅原始信号，就会调用原始信号中的didSubscribe</div><div class="line"> // 3.2 didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext</div><div class="line"> // 4.RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。</div><div class="line"> // 4.1 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock</div><div class="line"></div><div class="line"></div><div class="line"> // 需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。</div><div class="line"> // 解决：使用RACMulticastConnection就能解决.</div><div class="line"></div><div class="line"> // 1.创建请求信号</div><div class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line"></div><div class="line">     NSLog(@&quot;发送请求&quot;);</div><div class="line"></div><div class="line">     return nil;</div><div class="line"> &#125;];</div><div class="line"> // 2.订阅信号</div><div class="line"> [signal subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">     NSLog(@&quot;接收数据&quot;);</div><div class="line"></div><div class="line"> &#125;];</div><div class="line"> // 2.订阅信号</div><div class="line"> [signal subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">     NSLog(@&quot;接收数据&quot;);</div><div class="line"></div><div class="line"> &#125;];</div><div class="line"></div><div class="line"> // 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求</div><div class="line"></div><div class="line"></div><div class="line"> // RACMulticastConnection:解决重复请求问题</div><div class="line"> // 1.创建信号</div><div class="line"> RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line"></div><div class="line">     NSLog(@&quot;发送请求&quot;);</div><div class="line">     [subscriber sendNext:@1];</div><div class="line"></div><div class="line">     return nil;</div><div class="line"> &#125;];</div><div class="line"></div><div class="line"> // 2.创建连接</div><div class="line"> RACMulticastConnection *connect = [signal publish];</div><div class="line"></div><div class="line"> // 3.订阅信号，</div><div class="line"> // 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:</div><div class="line"> [connect.signal subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">     NSLog(@&quot;订阅者一信号&quot;);</div><div class="line"></div><div class="line"> &#125;];</div><div class="line"></div><div class="line"> [connect.signal subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">     NSLog(@&quot;订阅者二信号&quot;);</div><div class="line"></div><div class="line"> &#125;];</div><div class="line"></div><div class="line"> // 4.连接,激活信号</div><div class="line"> [connect connect];</div></pre></td></tr></table></figure>
<p><code>RACCommand</code>:RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。</p>
<p><code>使用场景</code>:监听按钮点击，网络请求</p>
<p><code>RACCommand简单使用</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">	// 一、RACCommand使用步骤:</div><div class="line">   // 1.创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock</div><div class="line">   // 2.在signalBlock中，创建RACSignal，并且作为signalBlock的返回值</div><div class="line">   // 3.执行命令 - (RACSignal *)execute:(id)input</div><div class="line"></div><div class="line">   // 二、RACCommand使用注意:</div><div class="line">   // 1.signalBlock必须要返回一个信号，不能传nil.</div><div class="line">   // 2.如果不想要传递信号，直接创建空的信号[RACSignal empty];</div><div class="line">   // 3.RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。</div><div class="line"></div><div class="line">   // 三、RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。</div><div class="line">   // 1.在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。</div><div class="line">   // 2.当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。</div><div class="line"></div><div class="line">   // 四、如何拿到RACCommand中返回信号发出的数据。</div><div class="line">   // 1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。</div><div class="line">   // 2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。</div><div class="line"></div><div class="line">   // 五、监听当前命令是否正在执行executing</div><div class="line"></div><div class="line">   // 六、使用场景,监听按钮点击，网络请求</div><div class="line"></div><div class="line"></div><div class="line">// 1.创建命令</div><div class="line">   RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123;</div><div class="line"></div><div class="line"></div><div class="line">       NSLog(@&quot;执行命令&quot;);</div><div class="line"></div><div class="line">       // 创建空信号,必须返回信号</div><div class="line">       //        return [RACSignal empty];</div><div class="line"></div><div class="line">       // 2.创建信号,用来传递数据</div><div class="line">       return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">           [subscriber sendNext:@&quot;请求数据&quot;];</div><div class="line"></div><div class="line">           // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。</div><div class="line">           [subscriber sendCompleted];</div><div class="line"></div><div class="line">           return nil;</div><div class="line">       &#125;];</div><div class="line"></div><div class="line">   &#125;];</div><div class="line"></div><div class="line">   // 强引用命令，不要被销毁，否则接收不到数据</div><div class="line">   _conmmand = command;</div><div class="line"></div><div class="line"></div><div class="line">   // 3.执行命令</div><div class="line">   [self.conmmand execute:@1];</div><div class="line"></div><div class="line">   // 4.订阅RACCommand中的信号</div><div class="line">   [command.executionSignals subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">       [x subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">           NSLog(@&quot;%@&quot;,x);</div><div class="line">       &#125;];</div><div class="line"></div><div class="line">   &#125;];</div><div class="line"></div><div class="line">   // RAC高级用法</div><div class="line">   // switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号</div><div class="line">   [command.executionSignals.switchToLatest subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">       NSLog(@&quot;%@&quot;,x);</div><div class="line">   &#125;];</div><div class="line"></div><div class="line">   // 5.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。</div><div class="line">   [[command.executing skip:1] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">       if ([x boolValue] == YES) &#123;</div><div class="line">           // 正在执行</div><div class="line">           NSLog(@&quot;正在执行&quot;);</div><div class="line"></div><div class="line">       &#125;else&#123;</div><div class="line">           // 执行完成</div><div class="line">           NSLog(@&quot;执行完成&quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
<p><code>RACScheduler</code>:RAC中的队列，用GCD封装的。</p>
<p><code>RACUnit</code> :表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil.</p>
<p><code>RACEvent</code>: 把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。</p>
<h3 id="6-ReactiveCocoa开发中常见用法。"><a href="#6-ReactiveCocoa开发中常见用法。" class="headerlink" title="6.ReactiveCocoa开发中常见用法。"></a>6.ReactiveCocoa开发中常见用法。</h3><p>6.1 代替代理:</p>
<ul>
<li><code>rac_signalForSelector</code>：用于替代代理。</li>
</ul>
<p>6.2 代替KVO :</p>
<ul>
<li><code>rac_valuesAndChangesForKeyPath</code>：用于监听某个对象的属性改变。</li>
</ul>
<p>6.3 监听事件:</p>
<ul>
<li><code>rac_signalForControlEvents</code>：用于监听某个事件。</li>
</ul>
<p>6.4 代替通知:</p>
<ul>
<li><code>rac_addObserverForName</code>:用于监听某个通知。</li>
</ul>
<p>6.5 监听文本框文字改变:</p>
<ul>
<li><code>rac_textSignal</code>:只要文本框发出改变就会发出这个信号。</li>
</ul>
<p>6.6 处理当界面有多次请求时，需要都获取到数据时，才能展示界面</p>
<ul>
<li><code>rac_liftSelector:withSignalsFromArray:Signals</code>:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。</li>
<li>使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</li>
</ul>
<p>6.7 代码演示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  	// 1.代替代理</div><div class="line">    // 需求：自定义redView,监听红色view中按钮点击</div><div class="line">    // 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情</div><div class="line">    // rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。</div><div class="line">    // 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。</div><div class="line">    [[redV rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id x) &#123;</div><div class="line">        NSLog(@&quot;点击红色按钮&quot;);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    // 2.KVO</div><div class="line">    // 把监听redV的center属性改变转换成信号，只要值改变就会发送信号</div><div class="line">    // observer:可以传入nil</div><div class="line">    [[redV rac_valuesAndChangesForKeyPath:@&quot;center&quot; options:NSKeyValueObservingOptionNew observer:nil] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">        NSLog(@&quot;%@&quot;,x);</div><div class="line"></div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    // 3.监听事件</div><div class="line">    // 把按钮点击事件转换为信号，点击按钮，就会发送信号</div><div class="line">    [[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">        NSLog(@&quot;按钮被点击了&quot;);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    // 4.代替通知</div><div class="line">    // 把监听到的通知转换信号</div><div class="line">    [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) &#123;</div><div class="line">        NSLog(@&quot;键盘弹出&quot;);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    // 5.监听文本框的文字改变</div><div class="line">   [_textField.rac_textSignal subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">       NSLog(@&quot;文字改变了%@&quot;,x);</div><div class="line">   &#125;];</div><div class="line"></div><div class="line">   // 6.处理多个请求，都返回结果的时候，统一做处理.</div><div class="line">    RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">        // 发送请求1</div><div class="line">        [subscriber sendNext:@&quot;发送请求1&quot;];</div><div class="line">        return nil;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        // 发送请求2</div><div class="line">        [subscriber sendNext:@&quot;发送请求2&quot;];</div><div class="line">        return nil;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    // 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</div><div class="line">    [self rac_liftSelector:@selector(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line">// 更新UI</div><div class="line">- (void)updateUIWithR1:(id)data r2:(id)data1</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;更新UI%@  %@&quot;,data,data1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="7-ReactiveCocoa常见宏。"><a href="#7-ReactiveCocoa常见宏。" class="headerlink" title="7.ReactiveCocoa常见宏。"></a>7.ReactiveCocoa常见宏。</h3><p>7.1 <code>RAC(TARGET, [KEYPATH, [NIL_VALUE]])</code>:用于给某个对象的某个属性绑定。</p>
<p><code>基本用法</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 只要文本框文字改变，就会修改label的文字</div><div class="line">   RAC(self.labelView,text) = _textField.rac_textSignal;</div></pre></td></tr></table></figure>
<p>7.2 <code>RACObserve(self, name)</code>:监听某个对象的某个属性,返回的是信号。</p>
<p><code>基本用法</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[RACObserve(self.view, center) subscribeNext:^(id x) &#123;</div><div class="line"></div><div class="line">        NSLog(@&quot;%@&quot;,x);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>7.3  <code>@weakify(Obj)和@strongify(Obj)</code>,一般两个都是配套使用,解决循环引用问题.</p>
<p>7.4 <code>RACTuplePack</code>：把数据包装成RACTuple（元组类）</p>
<p><code>基本用法</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 把参数中的数据包装成元组</div><div class="line">   RACTuple *tuple = RACTuplePack(@10,@20);</div></pre></td></tr></table></figure></p>
<p>7.5 <code>RACTupleUnpack</code>：把RACTuple（元组类）解包成对应的数据。</p>
<p><code>基本用法</code><br>```<br>    // 把参数中的数据包装成元组<br>    RACTuple *tuple = RACTuplePack(@”xmg”,@20);</p>
<pre><code>// 解包元组，会把元组的值，按顺序给参数里面的变量赋值
// name = @&quot;xmg&quot; age = @20
RACTupleUnpack(NSString *name,NSNumber *age) = tuple;
</code></pre><p><strong><a href="https://github.com/753331342/ReactiveCocoa-Demo.git" target="_blank" rel="external">Demo地址</a></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;1-ReactiveCocoa简介&quot;&gt;&lt;a href=&quot;#1-ReactiveCocoa简介&quot; class=&quot;headerlink&quot; title=&quot;1.ReactiveCocoa简介&quot;&gt;&lt;/a&gt;1.ReactiveCocoa简介
    
    </summary>
    
    
  </entry>
  
</feed>
